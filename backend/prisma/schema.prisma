// Prisma Schema for Rephlo Backend
// Database: PostgreSQL
// Generated: November 2025
// Updated: November 2025 - Added Dedicated API Backend schema

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// =============================================================================
// BRANDING WEBSITE MODELS (Legacy - Preserved)
// =============================================================================

// Download Tracking Model
// Tracks each download event by OS platform
model Download {
  id        String   @id @default(cuid())
  os        String // "windows", "macos", "linux"
  timestamp DateTime @default(now())
  userAgent String? // Optional browser/client user agent
  ipHash    String? // Hashed IP for anonymity and privacy

  @@index([os])
  @@index([timestamp])
  @@map("downloads")
}

// Feedback Submission Model
// Stores user feedback from website or desktop app
model Feedback {
  id        String   @id @default(cuid())
  userId    String? // Optional user ID from desktop app
  message   String   @db.VarChar(1000) // Max 1000 characters per PRD
  email     String? // Optional email for follow-up
  timestamp DateTime @default(now())

  @@index([timestamp])
  @@index([email])
  @@map("feedbacks")
}

// Diagnostic Data Model
// Tracks diagnostic log file submissions
// Note: Actual files stored in cloud storage (S3), only metadata here
model Diagnostic {
  id        String   @id @default(cuid())
  userId    String? // Optional user ID from desktop app
  filePath  String // Path to file in cloud storage (e.g., S3 key)
  fileSize  Int // File size in bytes (max 5MB = 5242880 per PRD)
  timestamp DateTime @default(now())

  @@index([timestamp])
  @@index([userId])
  @@map("diagnostics")
}

// App Version Model
// Manages release version metadata and download URLs
model AppVersion {
  id          String   @id @default(cuid())
  version     String   @unique // e.g., "1.0.0", "1.1.0-beta"
  releaseDate DateTime // When this version was released
  downloadUrl String // URL to binary file (e.g., S3, GitHub Releases)
  changelog   String   @db.Text // Markdown-formatted release notes
  isLatest    Boolean  @default(true) // Flag for current production version
  createdAt   DateTime @default(now())

  @@index([isLatest])
  @@map("app_versions")
}

// =============================================================================
// DEDICATED API BACKEND MODELS (New)
// =============================================================================

// Enums for subscription and usage tracking
enum SubscriptionTier {
  free
  pro
  enterprise

  @@map("subscription_tier")
}

enum SubscriptionStatus {
  active
  cancelled
  expired
  suspended

  @@map("subscription_status")
}

enum UsageOperation {
  completion
  chat
  embedding
  function_call

  @@map("usage_operation")
}

enum ModelCapability {
  text
  vision
  function_calling
  code
  long_context

  @@map("model_capability")
}

// Users Table
// Stores user account information for authentication and profile management
model User {
  id                String    @id @default(uuid()) @db.Uuid
  email             String    @unique @db.VarChar(255)
  emailVerified     Boolean   @default(false) @map("email_verified")
  username          String?   @db.VarChar(100)
  passwordHash      String?   @map("password_hash") @db.VarChar(255)
  firstName         String?   @map("first_name") @db.VarChar(100)
  lastName          String?   @map("last_name") @db.VarChar(100)
  profilePictureUrl String?   @map("profile_picture_url") @db.Text
  createdAt         DateTime  @default(now()) @map("created_at")
  updatedAt         DateTime  @updatedAt @map("updated_at")
  lastLoginAt       DateTime? @map("last_login_at")
  isActive          Boolean   @default(true) @map("is_active")
  deletedAt         DateTime? @map("deleted_at")

  // Email Verification Fields
  emailVerificationToken       String?   @map("email_verification_token") @db.VarChar(255)
  emailVerificationTokenExpiry DateTime? @map("email_verification_token_expiry")

  // Password Reset Fields
  passwordResetToken       String?   @map("password_reset_token") @db.VarChar(255)
  passwordResetTokenExpiry DateTime? @map("password_reset_token_expiry")

  // Account Management Fields
  deactivatedAt DateTime? @map("deactivated_at")

  // Social Auth Fields
  googleId         String? @unique @map("google_id") @db.VarChar(255)
  googleProfileUrl String? @map("google_profile_url") @db.Text
  authProvider     String  @default("local") @map("auth_provider") @db.VarChar(50)

  // Security/Audit Fields
  lastPasswordChange DateTime? @map("last_password_change")
  passwordResetCount Int       @default(0) @map("password_reset_count")

  // Role-Based Access Control
  role String @default("user") @map("role") @db.VarChar(20)
  // Values: "user", "admin"

  // Relations
  subscriptions      Subscription[]
  credits            Credit[]
  usageHistory       UsageHistory[]
  userPreferences    UserPreference?
  webhookConfigs     WebhookConfig[]
  modelTierAuditLogs ModelTierAuditLog[] @relation("ModelTierAuditLogs")

  // Plan 109 Subscription Monetization Relations
  subscriptionMonetization SubscriptionMonetization[] @relation("UserSubscriptionMonetization")
  creditAllocations        CreditAllocation[]         @relation("UserCreditAllocation")
  billingInvoices          BillingInvoice[]           @relation("UserBillingInvoice")
  paymentTransactions      PaymentTransaction[]       @relation("UserPaymentTransaction")
  dunningAttempts          DunningAttempt[]           @relation("UserDunningAttempt")

  // Plan 110 Perpetual Licensing Relations
  perpetualLicenses  PerpetualLicense[]  @relation("UserPerpetualLicense")
  licenseActivations LicenseActivation[] @relation("UserLicenseActivation")
  versionUpgrades    VersionUpgrade[]    @relation("UserVersionUpgrade")
  prorationEvents    ProrationEvent[]    @relation("UserProrationEvent")

  @@index([email])
  @@index([createdAt])
  @@index([googleId])
  @@index([role])
  @@map("users")
}

// OAuth Clients Table
// Stores OAuth 2.0 client configurations (e.g., desktop app, web app)
// Uses JSON config field for extensibility without schema migrations
model OAuthClient {
  clientId         String   @id @map("client_id") @db.VarChar(255)
  clientName       String   @map("client_name") @db.VarChar(255)
  clientSecretHash String?  @map("client_secret_hash") @db.VarChar(255)
  redirectUris     String[] @map("redirect_uris")
  grantTypes       String[] @map("grant_types")
  responseTypes    String[] @map("response_types")
  scope            String?  @db.Text
  isActive         Boolean  @default(true) @map("is_active")
  config           Json     @default("{}") @map("config")
  // Flexible JSON field for client-specific configuration:
  // {
  //   "skipConsentScreen": true,          // Skip consent & auto-approve after login
  //   "allowedOrigins": ["https://..."],  // Additional CORS origins
  //   "description": "...",                // Client description
  //   "tags": ["tag1", "tag2"],            // For categorization
  //   "...": "..."                         // Any future fields
  // }
  createdAt        DateTime @default(now()) @map("created_at")
  updatedAt        DateTime @updatedAt @map("updated_at")

  @@map("oauth_clients")
}

// Subscriptions Table
// Manages user subscription tiers, billing, and status
// Enhanced with Stripe integration and cancellation tracking
model Subscription {
  id              String             @id @default(uuid()) @db.Uuid
  userId          String             @map("user_id") @db.Uuid
  tier            SubscriptionTier
  status          SubscriptionStatus @default(active)
  creditsPerMonth Int                @map("credits_per_month")
  creditsRollover Boolean            @default(false) @map("credits_rollover")
  priceCents      Int                @map("price_cents")
  billingInterval String             @map("billing_interval") @db.VarChar(20)

  // Stripe Integration Fields (Enhanced)
  stripeSubscriptionId String? @unique @map("stripe_subscription_id") @db.VarChar(255)
  stripeCustomerId     String? @unique @map("stripe_customer_id") @db.VarChar(255)
  stripePriceId        String? @map("stripe_price_id") @db.VarChar(255)

  // Billing Period Fields
  currentPeriodStart DateTime  @map("current_period_start")
  currentPeriodEnd   DateTime  @map("current_period_end")
  trialEnd           DateTime? @map("trial_end")

  // Cancellation Tracking (Enhanced)
  cancelAtPeriodEnd Boolean   @default(false) @map("cancel_at_period_end")
  cancelledAt       DateTime? @map("cancelled_at")

  createdAt DateTime @default(now()) @map("created_at")
  updatedAt DateTime @updatedAt @map("updated_at")

  // Relations
  user    User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  credits Credit[]

  @@index([userId])
  @@index([status])
  @@index([currentPeriodEnd])
  @@map("subscriptions")
}

// Credits Table
// Tracks credit allocation and usage per billing period
// Enhanced with credit type tracking (free vs pro) and monthly allocation
model Credit {
  id                 String   @id @default(uuid()) @db.Uuid
  userId             String   @map("user_id") @db.Uuid
  subscriptionId     String?  @map("subscription_id") @db.Uuid
  totalCredits       Int      @map("total_credits")
  usedCredits        Int      @default(0) @map("used_credits")
  billingPeriodStart DateTime @map("billing_period_start")
  billingPeriodEnd   DateTime @map("billing_period_end")
  isCurrent          Boolean  @default(true) @map("is_current")

  // NEW FIELDS for Enhanced Credits Tracking
  creditType        String @default("free") @map("credit_type") @db.VarChar(10)
  // Values: 'free' | 'pro'
  monthlyAllocation Int    @default(2000) @map("monthly_allocation")
  // Free tier: 2000, Pro tier: configurable
  resetDayOfMonth   Int    @default(1) @map("reset_day_of_month")
  // Day of month when credits reset (1-31)

  createdAt DateTime @default(now()) @map("created_at")
  updatedAt DateTime @updatedAt @map("updated_at")

  // Relations
  user         User           @relation(fields: [userId], references: [id], onDelete: Cascade)
  subscription Subscription?  @relation(fields: [subscriptionId], references: [id], onDelete: SetNull)
  usageHistory UsageHistory[]

  @@index([userId])
  @@index([userId, isCurrent])
  @@index([userId, creditType, isCurrent], name: "idx_credits_user_type_current")
  @@index([billingPeriodStart, billingPeriodEnd])
  @@map("credits")
}

// Usage History Table
// Records detailed usage logs for each API request
model UsageHistory {
  id                String         @id @default(uuid()) @db.Uuid
  userId            String         @map("user_id") @db.Uuid
  creditId          String?        @map("credit_id") @db.Uuid
  modelId           String         @map("model_id") @db.VarChar(100)
  operation         UsageOperation
  creditsUsed       Int            @map("credits_used")
  inputTokens       Int?           @map("input_tokens")
  outputTokens      Int?           @map("output_tokens")
  totalTokens       Int?           @map("total_tokens")
  requestDurationMs Int?           @map("request_duration_ms")
  requestMetadata   Json?          @map("request_metadata")
  createdAt         DateTime       @default(now()) @map("created_at")

  // Relations
  user   User    @relation(fields: [userId], references: [id], onDelete: Cascade)
  credit Credit? @relation(fields: [creditId], references: [id], onDelete: SetNull)
  model  Model   @relation(fields: [modelId], references: [id])

  @@index([userId])
  @@index([createdAt])
  @@index([modelId])
  @@index([userId, createdAt(sort: Desc)])
  @@map("usage_history")
}

// Models Table
// Stores available LLM models with pricing and capability information
model Model {
  id                         String            @id @db.VarChar(100)
  name                       String            @db.VarChar(255)
  displayName                String            @map("display_name") @db.VarChar(255)
  provider                   String            @db.VarChar(100)
  description                String?           @db.Text
  capabilities               ModelCapability[]
  contextLength              Int               @map("context_length")
  maxOutputTokens            Int?              @map("max_output_tokens")
  inputCostPerMillionTokens  Int               @map("input_cost_per_million_tokens")
  outputCostPerMillionTokens Int               @map("output_cost_per_million_tokens")
  creditsPer1kTokens         Int               @map("credits_per_1k_tokens")
  isAvailable                Boolean           @default(true) @map("is_available")
  isDeprecated               Boolean           @default(false) @map("is_deprecated")
  version                    String?           @db.VarChar(50)
  createdAt                  DateTime          @default(now()) @map("created_at")
  updatedAt                  DateTime          @updatedAt @map("updated_at")

  // Tier Access Control Fields (Added: 2025-11-08)
  requiredTier        SubscriptionTier   @default(free) @map("required_tier")
  // Minimum tier required to access this model
  tierRestrictionMode String             @default("minimum") @map("tier_restriction_mode") @db.VarChar(20)
  // "minimum" = tier >= requiredTier, "exact" = tier == requiredTier, "whitelist" = use allowedTiers
  allowedTiers        SubscriptionTier[] @default([free, pro, enterprise]) @map("allowed_tiers")
  // Explicit whitelist of allowed tiers (used when mode = "whitelist")

  // Relations
  usageHistory    UsageHistory[]
  userPreferences UserPreference[]
  auditLogs       ModelTierAuditLog[]

  @@index([isAvailable])
  @@index([provider])
  @@index([requiredTier])
  @@index([isAvailable, requiredTier])
  @@map("models")
}

// User Preferences Table
// Stores user-specific preferences and default settings
// Enhanced with notification and alert preferences
model UserPreference {
  userId          String  @id @map("user_id") @db.Uuid
  defaultModelId  String? @map("default_model_id") @db.VarChar(100)
  enableStreaming Boolean @default(true) @map("enable_streaming")
  maxTokens       Int     @default(4096) @map("max_tokens")
  temperature     Decimal @default(0.7) @db.Decimal(3, 2)

  // NEW FIELDS for Enhanced User Profile
  emailNotifications Boolean @default(true) @map("email_notifications")
  // Whether user receives email notifications
  usageAlerts        Boolean @default(true) @map("usage_alerts")
  // Whether user receives usage threshold alerts

  preferencesMetadata Json?    @map("preferences_metadata")
  createdAt           DateTime @default(now()) @map("created_at")
  updatedAt           DateTime @updatedAt @map("updated_at")

  // Relations
  user         User   @relation(fields: [userId], references: [id], onDelete: Cascade)
  defaultModel Model? @relation(fields: [defaultModelId], references: [id])

  @@map("user_preferences")
}

// Webhook Config Table
// Stores user webhook endpoint configurations for event notifications
model WebhookConfig {
  id            String   @id @default(uuid()) @db.Uuid
  userId        String   @map("user_id") @db.Uuid
  webhookUrl    String   @map("webhook_url") @db.VarChar(2048)
  webhookSecret String   @map("webhook_secret") @db.VarChar(255)
  isActive      Boolean  @default(true) @map("is_active")
  createdAt     DateTime @default(now()) @map("created_at")
  updatedAt     DateTime @updatedAt @map("updated_at")

  // Relations
  user User         @relation(fields: [userId], references: [id], onDelete: Cascade)
  logs WebhookLog[]

  @@unique([userId]) // One webhook config per user
  @@index([userId])
  @@index([isActive])
  @@map("webhook_configs")
}

// Webhook Log Table
// Tracks webhook delivery attempts, responses, and failures
model WebhookLog {
  id              String    @id @default(uuid()) @db.Uuid
  webhookConfigId String    @map("webhook_config_id") @db.Uuid
  eventType       String    @map("event_type") @db.VarChar(100)
  payload         Json
  status          String    @db.VarChar(20) // "success", "failed", "pending"
  statusCode      Int?      @map("status_code")
  responseBody    String?   @map("response_body") @db.Text
  errorMessage    String?   @map("error_message") @db.Text
  attempts        Int       @default(1)
  createdAt       DateTime  @default(now()) @map("created_at")
  completedAt     DateTime? @map("completed_at")

  // Relations
  webhookConfig WebhookConfig @relation(fields: [webhookConfigId], references: [id], onDelete: Cascade)

  @@index([webhookConfigId])
  @@index([eventType])
  @@index([status])
  @@index([createdAt])
  @@map("webhook_logs")
}

// Model Tier Audit Log Table
// Tracks all changes to model tier configurations for compliance and auditing
model ModelTierAuditLog {
  id            String   @id @default(uuid()) @db.Uuid
  modelId       String   @map("model_id") @db.VarChar(100)
  adminUserId   String   @map("admin_user_id") @db.Uuid
  changeType    String   @map("change_type") @db.VarChar(50)
  // Values: "tier_update", "restriction_mode_update", "allowed_tiers_update"
  previousValue Json?    @map("previous_value")
  newValue      Json     @map("new_value")
  reason        String?  @db.Text
  ipAddress     String?  @map("ip_address") @db.VarChar(45)
  createdAt     DateTime @default(now()) @map("created_at")

  // Relations
  model Model @relation(fields: [modelId], references: [id], onDelete: Cascade)
  admin User  @relation("ModelTierAuditLogs", fields: [adminUserId], references: [id])

  @@index([modelId])
  @@index([adminUserId])
  @@index([createdAt])
  @@map("model_tier_audit_logs")
}

// =============================================================================
// SUBSCRIPTION MONETIZATION SYSTEM (Plan 109)
// Integrated with Token-to-Credit Conversion (Plan 112)
// =============================================================================

// Subscription Table
// Manages user subscription lifecycle with Stripe integration
// Links to credit_allocation for monthly credit grants
model SubscriptionMonetization {
  id     String @id @default(uuid()) @db.Uuid
  userId String @map("user_id") @db.Uuid

  // Subscription Details
  tier         String @db.VarChar(50)
  // Values: 'free', 'pro', 'pro_max', 'enterprise_pro', 'enterprise_max', 'perpetual'
  billingCycle String @map("billing_cycle") @db.VarChar(20)
  // Values: 'monthly', 'annual', 'lifetime' (for perpetual)
  status       String @db.VarChar(20)
  // Values: 'trial', 'active', 'past_due', 'cancelled', 'expired'

  // Pricing
  basePriceUsd            Decimal @map("base_price_usd") @db.Decimal(10, 2)
  monthlyCreditAllocation Int     @map("monthly_credit_allocation")

  // Stripe Integration
  stripeCustomerId     String? @unique @map("stripe_customer_id") @db.VarChar(255)
  stripeSubscriptionId String? @unique @map("stripe_subscription_id") @db.VarChar(255)

  // Billing Period
  currentPeriodStart DateTime  @map("current_period_start")
  currentPeriodEnd   DateTime  @map("current_period_end")
  trialEndsAt        DateTime? @map("trial_ends_at")

  // Cancellation Tracking
  cancelledAt DateTime? @map("cancelled_at")

  // Timestamps
  createdAt DateTime @default(now()) @map("created_at")
  updatedAt DateTime @updatedAt @map("updated_at")

  // Relations
  user                User                 @relation("UserSubscriptionMonetization", fields: [userId], references: [id], onDelete: Cascade)
  creditAllocations   CreditAllocation[]
  billingInvoices     BillingInvoice[]
  paymentTransactions PaymentTransaction[]
  dunningAttempts     DunningAttempt[]

  // Plan 110 Perpetual Licensing Relations
  prorationEvents ProrationEvent[]

  @@index([userId])
  @@index([status])
  @@index([tier])
  @@index([currentPeriodEnd])
  @@index([stripeCustomerId])
  @@index([stripeSubscriptionId])
  @@map("subscription_monetization")
}

// Subscription Tier Configuration Table
// Defines tier pricing, credit allocations, and features
// Managed via admin UI for dynamic pricing adjustments
model SubscriptionTierConfig {
  id String @id @default(uuid()) @db.Uuid

  // Tier Identification
  tierName String @unique @map("tier_name") @db.VarChar(50)
  // Values: 'free', 'pro', 'pro_max', 'enterprise_pro', 'enterprise_max', 'perpetual'

  // Pricing
  monthlyPriceUsd Decimal @map("monthly_price_usd") @db.Decimal(10, 2)
  annualPriceUsd  Decimal @map("annual_price_usd") @db.Decimal(10, 2)

  // Credit Allocation
  monthlyCreditAllocation Int @map("monthly_credit_allocation")
  maxCreditRollover       Int @map("max_credit_rollover")
  // Maximum credits that can roll over to next month

  // Features (JSONB for flexibility)
  features Json @default("{}")
  // Example: {"apiAccess": true, "prioritySupport": true, "maxProjects": 10}

  // Status
  isActive Boolean @default(true) @map("is_active")

  // Timestamps
  createdAt DateTime @default(now()) @map("created_at")
  updatedAt DateTime @updatedAt @map("updated_at")

  @@map("subscription_tier_config")
}

// Credit Allocation Table
// Tracks monthly credit grants to users
// Links to user_credit_balance from Plan 112 for actual balance tracking
model CreditAllocation {
  id             String  @id @default(uuid()) @db.Uuid
  userId         String  @map("user_id") @db.Uuid
  subscriptionId String? @map("subscription_id") @db.Uuid

  // Allocation Details
  amount                Int
  allocationPeriodStart DateTime @map("allocation_period_start")
  allocationPeriodEnd   DateTime @map("allocation_period_end")

  // Source Tracking
  source String @db.VarChar(50)
  // Values: 'subscription', 'bonus', 'admin_grant', 'referral', 'coupon'

  // Timestamps
  createdAt DateTime @default(now()) @map("created_at")

  // Relations
  user         User                      @relation("UserCreditAllocation", fields: [userId], references: [id], onDelete: Cascade)
  subscription SubscriptionMonetization? @relation(fields: [subscriptionId], references: [id], onDelete: SetNull)

  @@index([userId])
  @@index([subscriptionId])
  @@index([allocationPeriodStart, allocationPeriodEnd])
  @@index([source])
  @@map("credit_allocation")
}

// Billing Invoice Table
// Stores Stripe invoice records for subscription billing
// Provides audit trail and reconciliation with Stripe
model BillingInvoice {
  id             String  @id @default(uuid()) @db.Uuid
  userId         String  @map("user_id") @db.Uuid
  subscriptionId String? @map("subscription_id") @db.Uuid

  // Stripe Integration
  stripeInvoiceId String @unique @map("stripe_invoice_id") @db.VarChar(255)

  // Invoice Details
  amountDue  Decimal @map("amount_due") @db.Decimal(10, 2)
  amountPaid Decimal @map("amount_paid") @db.Decimal(10, 2)
  currency   String  @default("usd") @db.VarChar(3)
  status     String  @db.VarChar(20)
  // Values: 'draft', 'open', 'paid', 'void', 'uncollectible'

  // Billing Period
  periodStart DateTime @map("period_start")
  periodEnd   DateTime @map("period_end")

  // Stripe URLs
  invoicePdf       String? @map("invoice_pdf") @db.Text
  hostedInvoiceUrl String? @map("hosted_invoice_url") @db.Text

  // Timestamps
  createdAt DateTime  @default(now()) @map("created_at")
  paidAt    DateTime? @map("paid_at")

  // Relations
  user                User                      @relation("UserBillingInvoice", fields: [userId], references: [id], onDelete: Cascade)
  subscription        SubscriptionMonetization? @relation(fields: [subscriptionId], references: [id], onDelete: SetNull)
  paymentTransactions PaymentTransaction[]
  dunningAttempts     DunningAttempt[]

  @@index([userId])
  @@index([subscriptionId])
  @@index([stripeInvoiceId])
  @@index([status])
  @@index([periodStart, periodEnd])
  @@map("billing_invoice")
}

// Payment Transaction Table
// Records all payment attempts and completions
// Links to billing_invoice for payment history
model PaymentTransaction {
  id             String  @id @default(uuid()) @db.Uuid
  userId         String  @map("user_id") @db.Uuid
  invoiceId      String? @map("invoice_id") @db.Uuid
  subscriptionId String? @map("subscription_id") @db.Uuid

  // Stripe Integration
  stripePaymentIntentId String @unique @map("stripe_payment_intent_id") @db.VarChar(255)

  // Transaction Details
  amount   Decimal @db.Decimal(10, 2)
  currency String  @default("usd") @db.VarChar(3)
  status   String  @db.VarChar(20)
  // Values: 'pending', 'succeeded', 'failed', 'cancelled', 'refunded'

  // Payment Method
  paymentMethodType String? @map("payment_method_type") @db.VarChar(50)
  // Values: 'card', 'bank_account', 'paypal', etc.

  // Failure Tracking
  failureReason String? @map("failure_reason") @db.Text

  // Timestamps
  createdAt   DateTime  @default(now()) @map("created_at")
  completedAt DateTime? @map("completed_at")

  // Relations
  user         User                      @relation("UserPaymentTransaction", fields: [userId], references: [id], onDelete: Cascade)
  invoice      BillingInvoice?           @relation(fields: [invoiceId], references: [id], onDelete: SetNull)
  subscription SubscriptionMonetization? @relation(fields: [subscriptionId], references: [id], onDelete: SetNull)

  @@index([userId])
  @@index([invoiceId])
  @@index([subscriptionId])
  @@index([stripePaymentIntentId])
  @@index([status])
  @@index([createdAt])
  @@map("payment_transaction")
}

// Dunning Attempt Table
// Tracks failed payment retry attempts (dunning management)
// Implements automatic retry logic for failed payments
model DunningAttempt {
  id             String  @id @default(uuid()) @db.Uuid
  userId         String  @map("user_id") @db.Uuid
  invoiceId      String  @map("invoice_id") @db.Uuid
  subscriptionId String? @map("subscription_id") @db.Uuid

  // Retry Details
  attemptNumber Int       @map("attempt_number")
  scheduledAt   DateTime  @map("scheduled_at")
  attemptedAt   DateTime? @map("attempted_at")

  // Result Tracking
  result        String? @db.VarChar(20)
  // Values: 'success', 'failed', 'pending', 'skipped'
  failureReason String? @map("failure_reason") @db.Text

  // Next Retry
  nextRetryAt DateTime? @map("next_retry_at")

  // Timestamps
  createdAt DateTime @default(now()) @map("created_at")

  // Relations
  user         User                      @relation("UserDunningAttempt", fields: [userId], references: [id], onDelete: Cascade)
  invoice      BillingInvoice            @relation(fields: [invoiceId], references: [id], onDelete: Cascade)
  subscription SubscriptionMonetization? @relation(fields: [subscriptionId], references: [id], onDelete: SetNull)

  @@index([userId])
  @@index([invoiceId])
  @@index([subscriptionId])
  @@index([scheduledAt])
  @@index([result])
  @@map("dunning_attempt")
}

// =============================================================================
// PERPETUAL LICENSING SYSTEM (Plan 110)
// Integrated with Subscription Monetization (Plan 109) and Token-to-Credit (Plan 112)
// =============================================================================

// Enums for Perpetual Licensing
enum LicenseStatus {
  pending // License created but not yet activated
  active // License active and in use
  suspended // Temporarily suspended (payment issues, policy violations)
  revoked // Permanently revoked (fraud, abuse)
  expired // Version support ended (v1.x EOL)

  @@map("license_status")
}

enum ActivationStatus {
  active // Device is actively using the license
  deactivated // User manually deactivated
  replaced // Device replaced by new activation

  @@map("activation_status")
}

enum UpgradeStatus {
  pending // Upgrade payment initiated but not completed
  completed // Upgrade payment completed and applied
  failed // Payment failed
  refunded // Upgrade refunded

  @@map("upgrade_status")
}

enum ProrationChangeType {
  upgrade // User upgraded to higher tier
  downgrade // User downgraded to lower tier
  cancellation // User cancelled subscription
  reactivation // User reactivated subscription

  @@map("proration_change_type")
}

enum ProrationStatus {
  pending // Proration calculated but not yet applied
  applied // Proration applied to Stripe invoice
  failed // Proration application failed
  reversed // Proration reversed (refund/adjustment)

  @@map("proration_status")
}

// Perpetual License Table
// Manages one-time perpetual license purchases with version eligibility tracking
// Links to User for ownership and subscription_monetization for migrations
model PerpetualLicense {
  id     String @id @default(uuid()) @db.Uuid
  userId String @map("user_id") @db.Uuid

  // License Key (Format: REPHLO-XXXX-XXXX-XXXX-XXXX)
  licenseKey String @unique @map("license_key") @db.VarChar(50)

  // Purchase Details
  purchasePriceUsd Decimal @map("purchase_price_usd") @db.Decimal(10, 2)
  purchasedVersion String  @map("purchased_version") @db.VarChar(50)
  // SemVer format: "1.0.0", "2.0.0"

  // Version Eligibility (SemVer)
  eligibleUntilVersion String @map("eligible_until_version") @db.VarChar(50)
  // Example: "1.99.99" means free updates to all v1.x releases

  // Activation Limits
  maxActivations     Int @default(3) @map("max_activations")
  currentActivations Int @default(0) @map("current_activations")

  // Status
  status LicenseStatus @default(pending)

  // Dates
  purchasedAt DateTime  @default(now()) @map("purchased_at")
  activatedAt DateTime? @map("activated_at")
  expiresAt   DateTime? @map("expires_at")
  // NULL for perpetual, set for EOL date (e.g., v1.x EOL after v2.0 launch + 12 months)

  // Timestamps
  createdAt DateTime @default(now()) @map("created_at")
  updatedAt DateTime @updatedAt @map("updated_at")

  // Relations
  user            User                @relation("UserPerpetualLicense", fields: [userId], references: [id], onDelete: Cascade)
  activations     LicenseActivation[]
  versionUpgrades VersionUpgrade[]

  @@index([userId])
  @@index([status])
  @@index([licenseKey])
  @@index([purchasedAt])
  @@map("perpetual_license")
}

// License Activation Table
// Tracks device activations with machine fingerprinting for fraud prevention
// Implements 3-device limit per license with deactivation support
model LicenseActivation {
  id        String @id @default(uuid()) @db.Uuid
  licenseId String @map("license_id") @db.Uuid
  userId    String @map("user_id") @db.Uuid

  // Machine Fingerprinting (SHA-256 hash)
  machineFingerprint String @map("machine_fingerprint") @db.VarChar(64)
  // SHA-256 hash of: CPU ID + MAC address + disk serial + OS version

  // Device Information
  deviceName String? @map("device_name") @db.VarChar(255)
  osType     String? @map("os_type") @db.VarChar(50)
  // Values: "Windows", "macOS", "Linux"
  osVersion  String? @map("os_version") @db.VarChar(100)
  cpuInfo    String? @map("cpu_info") @db.VarChar(255)

  // Activation Tracking
  activatedAt   DateTime  @default(now()) @map("activated_at")
  lastSeenAt    DateTime  @updatedAt @map("last_seen_at")
  deactivatedAt DateTime? @map("deactivated_at")

  // Status
  status ActivationStatus @default(active)

  // Timestamps
  createdAt DateTime @default(now()) @map("created_at")
  updatedAt DateTime @updatedAt @map("updated_at")

  // Relations
  license PerpetualLicense @relation(fields: [licenseId], references: [id], onDelete: Cascade)
  user    User             @relation("UserLicenseActivation", fields: [userId], references: [id], onDelete: Cascade)

  @@unique([licenseId, machineFingerprint], name: "unique_license_machine")
  @@index([licenseId])
  @@index([userId])
  @@index([machineFingerprint])
  @@index([status])
  @@index([activatedAt])
  @@map("license_activation")
}

// Version Upgrade Table
// Tracks major version upgrade purchases (e.g., v1.x → v2.0 for $99)
// Implements SemVer upgrade eligibility and payment tracking
model VersionUpgrade {
  id        String @id @default(uuid()) @db.Uuid
  licenseId String @map("license_id") @db.Uuid
  userId    String @map("user_id") @db.Uuid

  // Version Details (SemVer)
  fromVersion String @map("from_version") @db.VarChar(50)
  // Example: "1.9.5"
  toVersion   String @map("to_version") @db.VarChar(50)
  // Example: "2.0.0"

  // Pricing
  upgradePriceUsd Decimal @map("upgrade_price_usd") @db.Decimal(10, 2)
  // Standard: $99, Early bird: $79, Loyalty: $69

  // Stripe Payment Integration
  stripePaymentIntentId String? @unique @map("stripe_payment_intent_id") @db.VarChar(255)

  // Status
  status UpgradeStatus @default(pending)

  // Timestamps
  purchasedAt DateTime @default(now()) @map("purchased_at")
  createdAt   DateTime @default(now()) @map("created_at")
  updatedAt   DateTime @updatedAt @map("updated_at")

  // Relations
  license PerpetualLicense @relation(fields: [licenseId], references: [id], onDelete: Cascade)
  user    User             @relation("UserVersionUpgrade", fields: [userId], references: [id], onDelete: Cascade)

  @@index([licenseId])
  @@index([userId])
  @@index([fromVersion, toVersion])
  @@index([status])
  @@index([purchasedAt])
  @@map("version_upgrade")
}

// Proration Event Table
// Tracks mid-cycle tier changes with prorated credit calculations
// Integrates with subscription_monetization for tier change billing
model ProrationEvent {
  id             String @id @default(uuid()) @db.Uuid
  userId         String @map("user_id") @db.Uuid
  subscriptionId String @map("subscription_id") @db.Uuid

  // Tier Change Details
  fromTier String? @map("from_tier") @db.VarChar(50)
  // Values: 'free', 'pro', 'pro_max', 'enterprise_pro', 'enterprise_max', 'perpetual'
  toTier   String? @map("to_tier") @db.VarChar(50)

  // Change Type
  changeType ProrationChangeType

  // Billing Cycle Details
  daysRemaining Int @map("days_remaining")
  daysInCycle   Int @map("days_in_cycle")

  // Proration Calculation (in USD)
  unusedCreditValueUsd   Decimal @map("unused_credit_value_usd") @db.Decimal(10, 2)
  // Credit from old tier: (days_remaining / days_in_cycle) × old_tier_price
  newTierProratedCostUsd Decimal @map("new_tier_prorated_cost_usd") @db.Decimal(10, 2)
  // Cost for new tier: (days_remaining / days_in_cycle) × new_tier_price
  netChargeUsd           Decimal @map("net_charge_usd") @db.Decimal(10, 2)
  // Net charge: new_tier_cost - unused_credit (positive = charge, negative = credit)

  // Dates
  effectiveDate DateTime @map("effective_date")

  // Stripe Integration
  stripeInvoiceId String? @unique @map("stripe_invoice_id") @db.VarChar(255)

  // Status
  status ProrationStatus @default(pending)

  // Timestamps
  createdAt DateTime @default(now()) @map("created_at")
  updatedAt DateTime @updatedAt @map("updated_at")

  // Relations
  user         User                     @relation("UserProrationEvent", fields: [userId], references: [id], onDelete: Cascade)
  subscription SubscriptionMonetization @relation(fields: [subscriptionId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([subscriptionId])
  @@index([changeType])
  @@index([effectiveDate])
  @@index([status])
  @@map("proration_event")
}
