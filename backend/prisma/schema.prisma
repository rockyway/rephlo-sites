// Prisma Schema for Rephlo Backend
// Database: PostgreSQL
// Generated: November 2025
// Updated: November 2025 - Added Dedicated API Backend schema

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// =============================================================================
// BRANDING WEBSITE MODELS (Legacy - Preserved)
// =============================================================================

// Download Tracking Model
// Tracks each download event by OS platform
model Download {
  id        String   @id @default(cuid())
  os        String // "windows", "macos", "linux"
  timestamp DateTime @default(now())
  userAgent String? // Optional browser/client user agent
  ipHash    String? // Hashed IP for anonymity and privacy

  @@index([os])
  @@index([timestamp])
  @@map("downloads")
}

// Feedback Submission Model
// Stores user feedback from website or desktop app
model Feedback {
  id        String   @id @default(cuid())
  userId    String? // Optional user ID from desktop app
  message   String   @db.VarChar(1000) // Max 1000 characters per PRD
  email     String? // Optional email for follow-up
  timestamp DateTime @default(now())

  @@index([timestamp])
  @@index([email])
  @@map("feedbacks")
}

// Diagnostic Data Model
// Tracks diagnostic log file submissions
// Note: Actual files stored in cloud storage (S3), only metadata here
model Diagnostic {
  id        String   @id @default(cuid())
  userId    String? // Optional user ID from desktop app
  filePath  String // Path to file in cloud storage (e.g., S3 key)
  fileSize  Int // File size in bytes (max 5MB = 5242880 per PRD)
  timestamp DateTime @default(now())

  @@index([timestamp])
  @@index([userId])
  @@map("diagnostics")
}

// App Version Model
// Manages release version metadata and download URLs
model AppVersion {
  id          String   @id @default(cuid())
  version     String   @unique // e.g., "1.0.0", "1.1.0-beta"
  releaseDate DateTime // When this version was released
  downloadUrl String // URL to binary file (e.g., S3, GitHub Releases)
  changelog   String   @db.Text // Markdown-formatted release notes
  isLatest    Boolean  @default(true) // Flag for current production version
  createdAt   DateTime @default(now())

  @@index([isLatest])
  @@map("app_versions")
}

// =============================================================================
// DEDICATED API BACKEND MODELS (New)
// =============================================================================

// Enums for subscription and usage tracking
enum SubscriptionTier {
  free
  pro
  enterprise

  @@map("subscription_tier")
}

enum SubscriptionStatus {
  active
  cancelled
  expired
  suspended

  @@map("subscription_status")
}

enum UsageOperation {
  completion
  chat
  embedding
  function_call

  @@map("usage_operation")
}

enum ModelCapability {
  text
  vision
  function_calling
  code
  long_context

  @@map("model_capability")
}

// Users Table
// Stores user account information for authentication and profile management
model User {
  id                String    @id @default(uuid()) @db.Uuid
  email             String    @unique @db.VarChar(255)
  emailVerified     Boolean   @default(false) @map("email_verified")
  username          String?   @db.VarChar(100)
  passwordHash      String?   @map("password_hash") @db.VarChar(255)
  firstName         String?   @map("first_name") @db.VarChar(100)
  lastName          String?   @map("last_name") @db.VarChar(100)
  profilePictureUrl String?   @map("profile_picture_url") @db.Text
  createdAt         DateTime  @default(now()) @map("created_at")
  updatedAt         DateTime  @updatedAt @map("updated_at")
  lastLoginAt       DateTime? @map("last_login_at")
  isActive          Boolean   @default(true) @map("is_active")
  deletedAt         DateTime? @map("deleted_at")

  // Email Verification Fields
  emailVerificationToken       String?   @map("email_verification_token") @db.VarChar(255)
  emailVerificationTokenExpiry DateTime? @map("email_verification_token_expiry")

  // Password Reset Fields
  passwordResetToken       String?   @map("password_reset_token") @db.VarChar(255)
  passwordResetTokenExpiry DateTime? @map("password_reset_token_expiry")

  // Account Management Fields
  deactivatedAt DateTime? @map("deactivated_at")

  // Social Auth Fields
  googleId         String? @unique @map("google_id") @db.VarChar(255)
  googleProfileUrl String? @map("google_profile_url") @db.Text
  authProvider     String  @default("local") @map("auth_provider") @db.VarChar(50)

  // Security/Audit Fields
  lastPasswordChange DateTime? @map("last_password_change")
  passwordResetCount Int       @default(0) @map("password_reset_count")

  // Role-Based Access Control
  role String @default("user") @map("role") @db.VarChar(20)
  // Values: "user", "admin"

  // Relations
  subscriptions      Subscription[]
  credits            Credit[]
  usageHistory       UsageHistory[]
  userPreferences    UserPreference?
  webhookConfigs     WebhookConfig[]
  modelTierAuditLogs ModelTierAuditLog[] @relation("ModelTierAuditLogs")

  // Plan 109 Subscription Monetization Relations
  subscriptionMonetization SubscriptionMonetization[] @relation("UserSubscriptionMonetization")
  creditAllocations        CreditAllocation[]         @relation("UserCreditAllocation")
  billingInvoices          BillingInvoice[]           @relation("UserBillingInvoice")
  paymentTransactions      PaymentTransaction[]       @relation("UserPaymentTransaction")
  dunningAttempts          DunningAttempt[]           @relation("UserDunningAttempt")

  // Plan 110 Perpetual Licensing Relations
  perpetualLicenses  PerpetualLicense[]  @relation("UserPerpetualLicense")
  licenseActivations LicenseActivation[] @relation("UserLicenseActivation")
  versionUpgrades    VersionUpgrade[]    @relation("UserVersionUpgrade")
  prorationEvents    ProrationEvent[]    @relation("UserProrationEvent")

  @@index([email])
  @@index([createdAt])
  @@index([googleId])
  @@index([role])
  @@map("users")
}

// OAuth Clients Table
// Stores OAuth 2.0 client configurations (e.g., desktop app, web app)
// Uses JSON config field for extensibility without schema migrations
model OAuthClient {
  clientId         String   @id @map("client_id") @db.VarChar(255)
  clientName       String   @map("client_name") @db.VarChar(255)
  clientSecretHash String?  @map("client_secret_hash") @db.VarChar(255)
  redirectUris     String[] @map("redirect_uris")
  grantTypes       String[] @map("grant_types")
  responseTypes    String[] @map("response_types")
  scope            String?  @db.Text
  isActive         Boolean  @default(true) @map("is_active")
  config           Json     @default("{}") @map("config")
  // Flexible JSON field for client-specific configuration:
  // {
  //   "skipConsentScreen": true,          // Skip consent & auto-approve after login
  //   "allowedOrigins": ["https://..."],  // Additional CORS origins
  //   "description": "...",                // Client description
  //   "tags": ["tag1", "tag2"],            // For categorization
  //   "...": "..."                         // Any future fields
  // }
  createdAt        DateTime @default(now()) @map("created_at")
  updatedAt        DateTime @updatedAt @map("updated_at")

  @@map("oauth_clients")
}

// Subscriptions Table
// Manages user subscription tiers, billing, and status
// Enhanced with Stripe integration and cancellation tracking
model Subscription {
  id              String             @id @default(uuid()) @db.Uuid
  userId          String             @map("user_id") @db.Uuid
  tier            SubscriptionTier
  status          SubscriptionStatus @default(active)
  creditsPerMonth Int                @map("credits_per_month")
  creditsRollover Boolean            @default(false) @map("credits_rollover")
  priceCents      Int                @map("price_cents")
  billingInterval String             @map("billing_interval") @db.VarChar(20)

  // Stripe Integration Fields (Enhanced)
  stripeSubscriptionId String? @unique @map("stripe_subscription_id") @db.VarChar(255)
  stripeCustomerId     String? @unique @map("stripe_customer_id") @db.VarChar(255)
  stripePriceId        String? @map("stripe_price_id") @db.VarChar(255)

  // Billing Period Fields
  currentPeriodStart DateTime  @map("current_period_start")
  currentPeriodEnd   DateTime  @map("current_period_end")
  trialEnd           DateTime? @map("trial_end")

  // Cancellation Tracking (Enhanced)
  cancelAtPeriodEnd Boolean   @default(false) @map("cancel_at_period_end")
  cancelledAt       DateTime? @map("cancelled_at")

  createdAt DateTime @default(now()) @map("created_at")
  updatedAt DateTime @updatedAt @map("updated_at")

  // Relations
  user    User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  credits Credit[]

  @@index([userId])
  @@index([status])
  @@index([currentPeriodEnd])
  @@map("subscriptions")
}

// Credits Table
// Tracks credit allocation and usage per billing period
// Enhanced with credit type tracking (free vs pro) and monthly allocation
model Credit {
  id                 String   @id @default(uuid()) @db.Uuid
  userId             String   @map("user_id") @db.Uuid
  subscriptionId     String?  @map("subscription_id") @db.Uuid
  totalCredits       Int      @map("total_credits")
  usedCredits        Int      @default(0) @map("used_credits")
  billingPeriodStart DateTime @map("billing_period_start")
  billingPeriodEnd   DateTime @map("billing_period_end")
  isCurrent          Boolean  @default(true) @map("is_current")

  // NEW FIELDS for Enhanced Credits Tracking
  creditType        String @default("free") @map("credit_type") @db.VarChar(10)
  // Values: 'free' | 'pro'
  monthlyAllocation Int    @default(2000) @map("monthly_allocation")
  // Free tier: 2000, Pro tier: configurable
  resetDayOfMonth   Int    @default(1) @map("reset_day_of_month")
  // Day of month when credits reset (1-31)

  createdAt DateTime @default(now()) @map("created_at")
  updatedAt DateTime @updatedAt @map("updated_at")

  // Relations
  user         User           @relation(fields: [userId], references: [id], onDelete: Cascade)
  subscription Subscription?  @relation(fields: [subscriptionId], references: [id], onDelete: SetNull)
  usageHistory UsageHistory[]

  @@index([userId])
  @@index([userId, isCurrent])
  @@index([userId, creditType, isCurrent], name: "idx_credits_user_type_current")
  @@index([billingPeriodStart, billingPeriodEnd])
  @@map("credits")
}

// Usage History Table
// Records detailed usage logs for each API request
model UsageHistory {
  id                String         @id @default(uuid()) @db.Uuid
  userId            String         @map("user_id") @db.Uuid
  creditId          String?        @map("credit_id") @db.Uuid
  modelId           String         @map("model_id") @db.VarChar(100)
  operation         UsageOperation
  creditsUsed       Int            @map("credits_used")
  inputTokens       Int?           @map("input_tokens")
  outputTokens      Int?           @map("output_tokens")
  totalTokens       Int?           @map("total_tokens")
  requestDurationMs Int?           @map("request_duration_ms")
  requestMetadata   Json?          @map("request_metadata")
  createdAt         DateTime       @default(now()) @map("created_at")

  // Relations
  user   User    @relation(fields: [userId], references: [id], onDelete: Cascade)
  credit Credit? @relation(fields: [creditId], references: [id], onDelete: SetNull)
  model  Model   @relation(fields: [modelId], references: [id])

  @@index([userId])
  @@index([createdAt])
  @@index([modelId])
  @@index([userId, createdAt(sort: Desc)])
  @@map("usage_history")
}

// Models Table
// Stores available LLM models with pricing and capability information
model Model {
  id                         String            @id @db.VarChar(100)
  name                       String            @db.VarChar(255)
  displayName                String            @map("display_name") @db.VarChar(255)
  provider                   String            @db.VarChar(100)
  description                String?           @db.Text
  capabilities               ModelCapability[]
  contextLength              Int               @map("context_length")
  maxOutputTokens            Int?              @map("max_output_tokens")
  inputCostPerMillionTokens  Int               @map("input_cost_per_million_tokens")
  outputCostPerMillionTokens Int               @map("output_cost_per_million_tokens")
  creditsPer1kTokens         Int               @map("credits_per_1k_tokens")
  isAvailable                Boolean           @default(true) @map("is_available")
  isDeprecated               Boolean           @default(false) @map("is_deprecated")
  version                    String?           @db.VarChar(50)
  createdAt                  DateTime          @default(now()) @map("created_at")
  updatedAt                  DateTime          @updatedAt @map("updated_at")

  // Tier Access Control Fields (Added: 2025-11-08)
  requiredTier        SubscriptionTier   @default(free) @map("required_tier")
  // Minimum tier required to access this model
  tierRestrictionMode String             @default("minimum") @map("tier_restriction_mode") @db.VarChar(20)
  // "minimum" = tier >= requiredTier, "exact" = tier == requiredTier, "whitelist" = use allowedTiers
  allowedTiers        SubscriptionTier[] @default([free, pro, enterprise]) @map("allowed_tiers")
  // Explicit whitelist of allowed tiers (used when mode = "whitelist")

  // Relations
  usageHistory    UsageHistory[]
  userPreferences UserPreference[]
  auditLogs       ModelTierAuditLog[]

  @@index([isAvailable])
  @@index([provider])
  @@index([requiredTier])
  @@index([isAvailable, requiredTier])
  @@map("models")
}

// User Preferences Table
// Stores user-specific preferences and default settings
// Enhanced with notification and alert preferences
model UserPreference {
  userId          String  @id @map("user_id") @db.Uuid
  defaultModelId  String? @map("default_model_id") @db.VarChar(100)
  enableStreaming Boolean @default(true) @map("enable_streaming")
  maxTokens       Int     @default(4096) @map("max_tokens")
  temperature     Decimal @default(0.7) @db.Decimal(3, 2)

  // NEW FIELDS for Enhanced User Profile
  emailNotifications Boolean @default(true) @map("email_notifications")
  // Whether user receives email notifications
  usageAlerts        Boolean @default(true) @map("usage_alerts")
  // Whether user receives usage threshold alerts

  preferencesMetadata Json?    @map("preferences_metadata")
  createdAt           DateTime @default(now()) @map("created_at")
  updatedAt           DateTime @updatedAt @map("updated_at")

  // Relations
  user         User   @relation(fields: [userId], references: [id], onDelete: Cascade)
  defaultModel Model? @relation(fields: [defaultModelId], references: [id])

  @@map("user_preferences")
}

// Webhook Config Table
// Stores user webhook endpoint configurations for event notifications
model WebhookConfig {
  id            String   @id @default(uuid()) @db.Uuid
  userId        String   @map("user_id") @db.Uuid
  webhookUrl    String   @map("webhook_url") @db.VarChar(2048)
  webhookSecret String   @map("webhook_secret") @db.VarChar(255)
  isActive      Boolean  @default(true) @map("is_active")
  createdAt     DateTime @default(now()) @map("created_at")
  updatedAt     DateTime @updatedAt @map("updated_at")

  // Relations
  user User         @relation(fields: [userId], references: [id], onDelete: Cascade)
  logs WebhookLog[]

  @@unique([userId]) // One webhook config per user
  @@index([userId])
  @@index([isActive])
  @@map("webhook_configs")
}

// Webhook Log Table
// Tracks webhook delivery attempts, responses, and failures
model WebhookLog {
  id              String    @id @default(uuid()) @db.Uuid
  webhookConfigId String    @map("webhook_config_id") @db.Uuid
  eventType       String    @map("event_type") @db.VarChar(100)
  payload         Json
  status          String    @db.VarChar(20) // "success", "failed", "pending"
  statusCode      Int?      @map("status_code")
  responseBody    String?   @map("response_body") @db.Text
  errorMessage    String?   @map("error_message") @db.Text
  attempts        Int       @default(1)
  createdAt       DateTime  @default(now()) @map("created_at")
  completedAt     DateTime? @map("completed_at")

  // Relations
  webhookConfig WebhookConfig @relation(fields: [webhookConfigId], references: [id], onDelete: Cascade)

  @@index([webhookConfigId])
  @@index([eventType])
  @@index([status])
  @@index([createdAt])
  @@map("webhook_logs")
}

// Model Tier Audit Log Table
// Tracks all changes to model tier configurations for compliance and auditing
model ModelTierAuditLog {
  id            String   @id @default(uuid()) @db.Uuid
  modelId       String   @map("model_id") @db.VarChar(100)
  adminUserId   String   @map("admin_user_id") @db.Uuid
  changeType    String   @map("change_type") @db.VarChar(50)
  // Values: "tier_update", "restriction_mode_update", "allowed_tiers_update"
  previousValue Json?    @map("previous_value")
  newValue      Json     @map("new_value")
  reason        String?  @db.Text
  ipAddress     String?  @map("ip_address") @db.VarChar(45)
  createdAt     DateTime @default(now()) @map("created_at")

  // Relations
  model Model @relation(fields: [modelId], references: [id], onDelete: Cascade)
  admin User  @relation("ModelTierAuditLogs", fields: [adminUserId], references: [id])

  @@index([modelId])
  @@index([adminUserId])
  @@index([createdAt])
  @@map("model_tier_audit_logs")
}

// =============================================================================
// SUBSCRIPTION MONETIZATION SYSTEM (Plan 109)
// Integrated with Token-to-Credit Conversion (Plan 112)
// =============================================================================

// Subscription Table
// Manages user subscription lifecycle with Stripe integration
// Links to credit_allocation for monthly credit grants
model SubscriptionMonetization {
  id     String @id @default(uuid()) @db.Uuid
  userId String @map("user_id") @db.Uuid

  // Subscription Details
  tier         String @db.VarChar(50)
  // Values: 'free', 'pro', 'pro_max', 'enterprise_pro', 'enterprise_max', 'perpetual'
  billingCycle String @map("billing_cycle") @db.VarChar(20)
  // Values: 'monthly', 'annual', 'lifetime' (for perpetual)
  status       String @db.VarChar(20)
  // Values: 'trial', 'active', 'past_due', 'cancelled', 'expired'

  // Pricing
  basePriceUsd            Decimal @map("base_price_usd") @db.Decimal(10, 2)
  monthlyCreditAllocation Int     @map("monthly_credit_allocation")

  // Stripe Integration
  stripeCustomerId     String? @unique @map("stripe_customer_id") @db.VarChar(255)
  stripeSubscriptionId String? @unique @map("stripe_subscription_id") @db.VarChar(255)

  // Billing Period
  currentPeriodStart DateTime  @map("current_period_start")
  currentPeriodEnd   DateTime  @map("current_period_end")
  trialEndsAt        DateTime? @map("trial_ends_at")

  // Cancellation Tracking
  cancelledAt DateTime? @map("cancelled_at")

  // Timestamps
  createdAt DateTime @default(now()) @map("created_at")
  updatedAt DateTime @updatedAt @map("updated_at")

  // Relations
  user                User                 @relation("UserSubscriptionMonetization", fields: [userId], references: [id], onDelete: Cascade)
  creditAllocations   CreditAllocation[]
  billingInvoices     BillingInvoice[]
  paymentTransactions PaymentTransaction[]
  dunningAttempts     DunningAttempt[]

  // Plan 110 Perpetual Licensing Relations
  prorationEvents ProrationEvent[]

  // Plan 111 Coupon System Relations
  couponRedemptions CouponRedemption[]

  @@index([userId])
  @@index([status])
  @@index([tier])
  @@index([currentPeriodEnd])
  @@index([stripeCustomerId])
  @@index([stripeSubscriptionId])
  @@map("subscription_monetization")
}

// Subscription Tier Configuration Table
// Defines tier pricing, credit allocations, and features
// Managed via admin UI for dynamic pricing adjustments
model SubscriptionTierConfig {
  id String @id @default(uuid()) @db.Uuid

  // Tier Identification
  tierName String @unique @map("tier_name") @db.VarChar(50)
  // Values: 'free', 'pro', 'pro_max', 'enterprise_pro', 'enterprise_max', 'perpetual'

  // Pricing
  monthlyPriceUsd Decimal @map("monthly_price_usd") @db.Decimal(10, 2)
  annualPriceUsd  Decimal @map("annual_price_usd") @db.Decimal(10, 2)

  // Credit Allocation
  monthlyCreditAllocation Int @map("monthly_credit_allocation")
  maxCreditRollover       Int @map("max_credit_rollover")
  // Maximum credits that can roll over to next month

  // Features (JSONB for flexibility)
  features Json @default("{}")
  // Example: {"apiAccess": true, "prioritySupport": true, "maxProjects": 10}

  // Status
  isActive Boolean @default(true) @map("is_active")

  // Timestamps
  createdAt DateTime @default(now()) @map("created_at")
  updatedAt DateTime @updatedAt @map("updated_at")

  @@map("subscription_tier_config")
}

// Credit Allocation Table
// Tracks monthly credit grants to users
// Links to user_credit_balance from Plan 112 for actual balance tracking
model CreditAllocation {
  id             String  @id @default(uuid()) @db.Uuid
  userId         String  @map("user_id") @db.Uuid
  subscriptionId String? @map("subscription_id") @db.Uuid

  // Allocation Details
  amount                Int
  allocationPeriodStart DateTime @map("allocation_period_start")
  allocationPeriodEnd   DateTime @map("allocation_period_end")

  // Source Tracking
  source String @db.VarChar(50)
  // Values: 'subscription', 'bonus', 'admin_grant', 'referral', 'coupon'

  // Timestamps
  createdAt DateTime @default(now()) @map("created_at")

  // Relations
  user         User                      @relation("UserCreditAllocation", fields: [userId], references: [id], onDelete: Cascade)
  subscription SubscriptionMonetization? @relation(fields: [subscriptionId], references: [id], onDelete: SetNull)

  @@index([userId])
  @@index([subscriptionId])
  @@index([allocationPeriodStart, allocationPeriodEnd])
  @@index([source])
  @@map("credit_allocation")
}

// Billing Invoice Table
// Stores Stripe invoice records for subscription billing
// Provides audit trail and reconciliation with Stripe
model BillingInvoice {
  id             String  @id @default(uuid()) @db.Uuid
  userId         String  @map("user_id") @db.Uuid
  subscriptionId String? @map("subscription_id") @db.Uuid

  // Stripe Integration
  stripeInvoiceId String @unique @map("stripe_invoice_id") @db.VarChar(255)

  // Invoice Details
  amountDue  Decimal @map("amount_due") @db.Decimal(10, 2)
  amountPaid Decimal @map("amount_paid") @db.Decimal(10, 2)
  currency   String  @default("usd") @db.VarChar(3)
  status     String  @db.VarChar(20)
  // Values: 'draft', 'open', 'paid', 'void', 'uncollectible'

  // Billing Period
  periodStart DateTime @map("period_start")
  periodEnd   DateTime @map("period_end")

  // Stripe URLs
  invoicePdf       String? @map("invoice_pdf") @db.Text
  hostedInvoiceUrl String? @map("hosted_invoice_url") @db.Text

  // Timestamps
  createdAt DateTime  @default(now()) @map("created_at")
  paidAt    DateTime? @map("paid_at")

  // Relations
  user                User                      @relation("UserBillingInvoice", fields: [userId], references: [id], onDelete: Cascade)
  subscription        SubscriptionMonetization? @relation(fields: [subscriptionId], references: [id], onDelete: SetNull)
  paymentTransactions PaymentTransaction[]
  dunningAttempts     DunningAttempt[]

  @@index([userId])
  @@index([subscriptionId])
  @@index([stripeInvoiceId])
  @@index([status])
  @@index([periodStart, periodEnd])
  @@map("billing_invoice")
}

// Payment Transaction Table
// Records all payment attempts and completions
// Links to billing_invoice for payment history
model PaymentTransaction {
  id             String  @id @default(uuid()) @db.Uuid
  userId         String  @map("user_id") @db.Uuid
  invoiceId      String? @map("invoice_id") @db.Uuid
  subscriptionId String? @map("subscription_id") @db.Uuid

  // Stripe Integration
  stripePaymentIntentId String @unique @map("stripe_payment_intent_id") @db.VarChar(255)

  // Transaction Details
  amount   Decimal @db.Decimal(10, 2)
  currency String  @default("usd") @db.VarChar(3)
  status   String  @db.VarChar(20)
  // Values: 'pending', 'succeeded', 'failed', 'cancelled', 'refunded'

  // Payment Method
  paymentMethodType String? @map("payment_method_type") @db.VarChar(50)
  // Values: 'card', 'bank_account', 'paypal', etc.

  // Failure Tracking
  failureReason String? @map("failure_reason") @db.Text

  // Timestamps
  createdAt   DateTime  @default(now()) @map("created_at")
  completedAt DateTime? @map("completed_at")

  // Relations
  user         User                      @relation("UserPaymentTransaction", fields: [userId], references: [id], onDelete: Cascade)
  invoice      BillingInvoice?           @relation(fields: [invoiceId], references: [id], onDelete: SetNull)
  subscription SubscriptionMonetization? @relation(fields: [subscriptionId], references: [id], onDelete: SetNull)

  @@index([userId])
  @@index([invoiceId])
  @@index([subscriptionId])
  @@index([stripePaymentIntentId])
  @@index([status])
  @@index([createdAt])
  @@map("payment_transaction")
}

// Dunning Attempt Table
// Tracks failed payment retry attempts (dunning management)
// Implements automatic retry logic for failed payments
model DunningAttempt {
  id             String  @id @default(uuid()) @db.Uuid
  userId         String  @map("user_id") @db.Uuid
  invoiceId      String  @map("invoice_id") @db.Uuid
  subscriptionId String? @map("subscription_id") @db.Uuid

  // Retry Details
  attemptNumber Int       @map("attempt_number")
  scheduledAt   DateTime  @map("scheduled_at")
  attemptedAt   DateTime? @map("attempted_at")

  // Result Tracking
  result        String? @db.VarChar(20)
  // Values: 'success', 'failed', 'pending', 'skipped'
  failureReason String? @map("failure_reason") @db.Text

  // Next Retry
  nextRetryAt DateTime? @map("next_retry_at")

  // Timestamps
  createdAt DateTime @default(now()) @map("created_at")

  // Relations
  user         User                      @relation("UserDunningAttempt", fields: [userId], references: [id], onDelete: Cascade)
  invoice      BillingInvoice            @relation(fields: [invoiceId], references: [id], onDelete: Cascade)
  subscription SubscriptionMonetization? @relation(fields: [subscriptionId], references: [id], onDelete: SetNull)

  @@index([userId])
  @@index([invoiceId])
  @@index([subscriptionId])
  @@index([scheduledAt])
  @@index([result])
  @@map("dunning_attempt")
}

// =============================================================================
// PERPETUAL LICENSING SYSTEM (Plan 110)
// Integrated with Subscription Monetization (Plan 109) and Token-to-Credit (Plan 112)
// =============================================================================

// Enums for Perpetual Licensing
enum LicenseStatus {
  pending // License created but not yet activated
  active // License active and in use
  suspended // Temporarily suspended (payment issues, policy violations)
  revoked // Permanently revoked (fraud, abuse)
  expired // Version support ended (v1.x EOL)

  @@map("license_status")
}

enum ActivationStatus {
  active // Device is actively using the license
  deactivated // User manually deactivated
  replaced // Device replaced by new activation

  @@map("activation_status")
}

enum UpgradeStatus {
  pending // Upgrade payment initiated but not completed
  completed // Upgrade payment completed and applied
  failed // Payment failed
  refunded // Upgrade refunded

  @@map("upgrade_status")
}

enum ProrationChangeType {
  upgrade // User upgraded to higher tier
  downgrade // User downgraded to lower tier
  cancellation // User cancelled subscription
  reactivation // User reactivated subscription

  @@map("proration_change_type")
}

enum ProrationStatus {
  pending // Proration calculated but not yet applied
  applied // Proration applied to Stripe invoice
  failed // Proration application failed
  reversed // Proration reversed (refund/adjustment)

  @@map("proration_status")
}

// Perpetual License Table
// Manages one-time perpetual license purchases with version eligibility tracking
// Links to User for ownership and subscription_monetization for migrations
model PerpetualLicense {
  id     String @id @default(uuid()) @db.Uuid
  userId String @map("user_id") @db.Uuid

  // License Key (Format: REPHLO-XXXX-XXXX-XXXX-XXXX)
  licenseKey String @unique @map("license_key") @db.VarChar(50)

  // Purchase Details
  purchasePriceUsd Decimal @map("purchase_price_usd") @db.Decimal(10, 2)
  purchasedVersion String  @map("purchased_version") @db.VarChar(50)
  // SemVer format: "1.0.0", "2.0.0"

  // Version Eligibility (SemVer)
  eligibleUntilVersion String @map("eligible_until_version") @db.VarChar(50)
  // Example: "1.99.99" means free updates to all v1.x releases

  // Activation Limits
  maxActivations     Int @default(3) @map("max_activations")
  currentActivations Int @default(0) @map("current_activations")

  // Status
  status LicenseStatus @default(pending)

  // Dates
  purchasedAt DateTime  @default(now()) @map("purchased_at")
  activatedAt DateTime? @map("activated_at")
  expiresAt   DateTime? @map("expires_at")
  // NULL for perpetual, set for EOL date (e.g., v1.x EOL after v2.0 launch + 12 months)

  // Timestamps
  createdAt DateTime @default(now()) @map("created_at")
  updatedAt DateTime @updatedAt @map("updated_at")

  // Relations
  user            User                @relation("UserPerpetualLicense", fields: [userId], references: [id], onDelete: Cascade)
  activations     LicenseActivation[]
  versionUpgrades VersionUpgrade[]

  @@index([userId])
  @@index([status])
  @@index([licenseKey])
  @@index([purchasedAt])
  @@map("perpetual_license")
}

// License Activation Table
// Tracks device activations with machine fingerprinting for fraud prevention
// Implements 3-device limit per license with deactivation support
model LicenseActivation {
  id        String @id @default(uuid()) @db.Uuid
  licenseId String @map("license_id") @db.Uuid
  userId    String @map("user_id") @db.Uuid

  // Machine Fingerprinting (SHA-256 hash)
  machineFingerprint String @map("machine_fingerprint") @db.VarChar(64)
  // SHA-256 hash of: CPU ID + MAC address + disk serial + OS version

  // Device Information
  deviceName String? @map("device_name") @db.VarChar(255)
  osType     String? @map("os_type") @db.VarChar(50)
  // Values: "Windows", "macOS", "Linux"
  osVersion  String? @map("os_version") @db.VarChar(100)
  cpuInfo    String? @map("cpu_info") @db.VarChar(255)

  // Activation Tracking
  activatedAt   DateTime  @default(now()) @map("activated_at")
  lastSeenAt    DateTime  @updatedAt @map("last_seen_at")
  deactivatedAt DateTime? @map("deactivated_at")

  // Status
  status ActivationStatus @default(active)

  // Timestamps
  createdAt DateTime @default(now()) @map("created_at")
  updatedAt DateTime @updatedAt @map("updated_at")

  // Relations
  license PerpetualLicense @relation(fields: [licenseId], references: [id], onDelete: Cascade)
  user    User             @relation("UserLicenseActivation", fields: [userId], references: [id], onDelete: Cascade)

  @@unique([licenseId, machineFingerprint], name: "unique_license_machine")
  @@index([licenseId])
  @@index([userId])
  @@index([machineFingerprint])
  @@index([status])
  @@index([activatedAt])
  @@map("license_activation")
}

// Version Upgrade Table
// Tracks major version upgrade purchases (e.g., v1.x → v2.0 for $99)
// Implements SemVer upgrade eligibility and payment tracking
model VersionUpgrade {
  id        String @id @default(uuid()) @db.Uuid
  licenseId String @map("license_id") @db.Uuid
  userId    String @map("user_id") @db.Uuid

  // Version Details (SemVer)
  fromVersion String @map("from_version") @db.VarChar(50)
  // Example: "1.9.5"
  toVersion   String @map("to_version") @db.VarChar(50)
  // Example: "2.0.0"

  // Pricing
  upgradePriceUsd Decimal @map("upgrade_price_usd") @db.Decimal(10, 2)
  // Standard: $99, Early bird: $79, Loyalty: $69

  // Stripe Payment Integration
  stripePaymentIntentId String? @unique @map("stripe_payment_intent_id") @db.VarChar(255)

  // Status
  status UpgradeStatus @default(pending)

  // Timestamps
  purchasedAt DateTime @default(now()) @map("purchased_at")
  createdAt   DateTime @default(now()) @map("created_at")
  updatedAt   DateTime @updatedAt @map("updated_at")

  // Relations
  license PerpetualLicense @relation(fields: [licenseId], references: [id], onDelete: Cascade)
  user    User             @relation("UserVersionUpgrade", fields: [userId], references: [id], onDelete: Cascade)

  @@index([licenseId])
  @@index([userId])
  @@index([fromVersion, toVersion])
  @@index([status])
  @@index([purchasedAt])
  @@map("version_upgrade")
}

// Proration Event Table
// Tracks mid-cycle tier changes with prorated credit calculations
// Integrates with subscription_monetization for tier change billing
model ProrationEvent {
  id             String @id @default(uuid()) @db.Uuid
  userId         String @map("user_id") @db.Uuid
  subscriptionId String @map("subscription_id") @db.Uuid

  // Tier Change Details
  fromTier String? @map("from_tier") @db.VarChar(50)
  // Values: 'free', 'pro', 'pro_max', 'enterprise_pro', 'enterprise_max', 'perpetual'
  toTier   String? @map("to_tier") @db.VarChar(50)

  // Change Type
  changeType ProrationChangeType

  // Billing Cycle Details
  daysRemaining Int @map("days_remaining")
  daysInCycle   Int @map("days_in_cycle")

  // Proration Calculation (in USD)
  unusedCreditValueUsd   Decimal @map("unused_credit_value_usd") @db.Decimal(10, 2)
  // Credit from old tier: (days_remaining / days_in_cycle) × old_tier_price
  newTierProratedCostUsd Decimal @map("new_tier_prorated_cost_usd") @db.Decimal(10, 2)
  // Cost for new tier: (days_remaining / days_in_cycle) × new_tier_price
  netChargeUsd           Decimal @map("net_charge_usd") @db.Decimal(10, 2)
  // Net charge: new_tier_cost - unused_credit (positive = charge, negative = credit)

  // Dates
  effectiveDate DateTime @map("effective_date")

  // Stripe Integration
  stripeInvoiceId String? @unique @map("stripe_invoice_id") @db.VarChar(255)

  // Status
  status ProrationStatus @default(pending)

  // Timestamps
  createdAt DateTime @default(now()) @map("created_at")
  updatedAt DateTime @updatedAt @map("updated_at")

  // Relations
  user         User                     @relation("UserProrationEvent", fields: [userId], references: [id], onDelete: Cascade)
  subscription SubscriptionMonetization @relation(fields: [subscriptionId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([subscriptionId])
  @@index([changeType])
  @@index([effectiveDate])
  @@index([status])
  @@map("proration_event")
}

// =============================================================================
// COUPON & DISCOUNT CODE SYSTEM (Plan 111)
// Integrated with Subscription Monetization (Plan 109) and Perpetual Licensing (Plan 110)
// =============================================================================

// Enums for Coupon System
enum CouponType {
  percentage_discount // Percentage off subscription price
  fixed_amount_discount // Fixed dollar amount off
  tier_specific_discount // Discount for specific tier upgrades
  duration_bonus // Free additional months
  byok_migration // Perpetual Plan migration discount

  @@map("coupon_type")
}

enum DiscountType {
  percentage // % discount (e.g., 25%)
  fixed_amount // $ discount (e.g., $20)
  credits // Credit allocation (e.g., 1000 credits)
  months_free // Free months (e.g., 1 month)

  @@map("discount_type")
}

enum CampaignType {
  seasonal // Holiday campaigns (Black Friday, July 4)
  win_back // Churned user re-engagement
  referral // Referral program
  promotional // Marketing campaigns
  early_bird // New product launch

  @@map("campaign_type")
}

enum RedemptionStatus {
  success // Coupon successfully redeemed
  failed // Redemption failed (validation error)
  reversed // Redemption reversed (refund/chargeback)
  pending // Redemption pending payment

  @@map("redemption_status")
}

enum FraudDetectionType {
  velocity_abuse // Multiple redemptions in short time
  ip_switching // Same user, multiple IPs
  bot_pattern // Automated bot-like behavior
  device_fingerprint_mismatch // Device fingerprint inconsistency
  stacking_abuse // Coupon stacking attempts

  @@map("fraud_detection_type")
}

enum FraudSeverity {
  low // Low risk, log only
  medium // Medium risk, flag for review
  high // High risk, block redemption
  critical // Critical risk, ban user

  @@map("fraud_severity")
}

enum ValidationRuleType {
  first_time_user_only // Only for users who have never subscribed
  specific_email_domain // Only for specific email domains
  minimum_credit_balance // Requires minimum credit balance
  exclude_refunded_users // Excludes users with refunds
  require_payment_method // Requires valid payment method on file

  @@map("validation_rule_type")
}

// Coupon Table
// Core coupon configuration with pricing, limits, and tier eligibility
// Links to campaigns for budget tracking and analytics
model Coupon {
  id   String     @id @default(uuid()) @db.Uuid
  code String     @unique @map("code") @db.VarChar(50)
  // Uppercase only: "JULY4LIBERTY", "BLACKFRIDAY50"
  // Regex: ^[A-Z0-9]{4,50}$

  // Coupon Type & Discount Configuration
  couponType    CouponType   @map("coupon_type")
  discountValue Decimal      @map("discount_value") @db.Decimal(10, 2)
  // For percentage: 25.00 = 25%, For fixed_amount: 20.00 = $20
  discountType  DiscountType @map("discount_type")
  currency      String       @default("usd") @db.VarChar(3)

  // Usage Limits
  maxUses        Int? @map("max_uses")
  // NULL = unlimited, otherwise max total redemptions
  maxUsesPerUser Int  @default(1) @map("max_uses_per_user")
  // Default: 1 use per user

  // Eligibility Restrictions
  minPurchaseAmount Decimal?              @map("min_purchase_amount") @db.Decimal(10, 2)
  // Minimum cart value required
  tierEligibility   SubscriptionTier[]    @default([free, pro, enterprise]) @map("tier_eligibility")
  // Tiers eligible to use this coupon
  billingCycles     String[]              @default(["monthly", "annual"]) @map("billing_cycles")
  // Applicable billing cycles

  // Validity Period
  validFrom  DateTime @map("valid_from")
  validUntil DateTime @map("valid_until")
  isActive   Boolean  @default(true) @map("is_active")

  // Campaign Association
  campaignId String? @map("campaign_id") @db.Uuid

  // Description & Metadata
  description   String? @db.Text
  internalNotes String? @map("internal_notes") @db.Text

  // Audit Fields
  createdBy String   @map("created_by") @db.Uuid
  createdAt DateTime @default(now()) @map("created_at")
  updatedAt DateTime @updatedAt @map("updated_at")

  // Relations
  campaign           CouponCampaign?          @relation(fields: [campaignId], references: [id], onDelete: SetNull)
  redemptions        CouponRedemption[]
  usageLimits        CouponUsageLimit?
  validationRules    CouponValidationRule[]
  fraudDetections    CouponFraudDetection[]
  analyticsSnapshots CouponAnalyticsSnapshot[]
  campaignCoupons    CampaignCoupon[]

  @@index([code, isActive])
  @@index([validFrom, validUntil, isActive])
  @@index([campaignId])
  @@index([couponType])
  @@map("coupon")
}

// Coupon Campaign Table
// Manages promotional campaigns that group related coupons
// Tracks budget limits and spending for ROI analysis
model CouponCampaign {
  id           String       @id @default(uuid()) @db.Uuid
  campaignName String       @map("campaign_name") @db.VarChar(255)
  campaignType CampaignType @map("campaign_type")

  // Timing
  startDate DateTime @map("start_date")
  endDate   DateTime @map("end_date")

  // Budget Management
  budgetLimitUsd Decimal @map("budget_limit_usd") @db.Decimal(12, 2)
  totalSpentUsd  Decimal @default(0) @map("total_spent_usd") @db.Decimal(12, 2)

  // Targeting
  targetTier SubscriptionTier? @map("target_tier")
  // NULL = all tiers, otherwise specific tier

  // Status
  isActive Boolean @default(true) @map("is_active")

  // Audit Fields
  createdBy String   @map("created_by") @db.Uuid
  createdAt DateTime @default(now()) @map("created_at")
  updatedAt DateTime @updatedAt @map("updated_at")

  // Relations
  coupons         Coupon[]
  campaignCoupons CampaignCoupon[]

  @@index([campaignType, isActive])
  @@index([startDate, endDate])
  @@index([targetTier])
  @@map("coupon_campaign")
}

// Campaign Coupon Junction Table
// Links campaigns to coupons (many-to-many relationship)
// Allows coupons to be part of multiple campaigns
model CampaignCoupon {
  id         String @id @default(uuid()) @db.Uuid
  campaignId String @map("campaign_id") @db.Uuid
  couponId   String @map("coupon_id") @db.Uuid

  createdAt DateTime @default(now()) @map("created_at")

  // Relations
  campaign CouponCampaign @relation(fields: [campaignId], references: [id], onDelete: Cascade)
  coupon   Coupon         @relation(fields: [couponId], references: [id], onDelete: Cascade)

  @@unique([campaignId, couponId], name: "unique_campaign_coupon")
  @@index([campaignId])
  @@index([couponId])
  @@map("campaign_coupon")
}

// Coupon Redemption Table
// Immutable ledger of all coupon usage with fraud detection metadata
// Links to subscription_monetization for discount application
model CouponRedemption {
  id             String  @id @default(uuid()) @db.Uuid
  couponId       String  @map("coupon_id") @db.Uuid
  userId         String  @map("user_id") @db.Uuid
  subscriptionId String? @map("subscription_id") @db.Uuid

  // Redemption Details
  redemptionDate DateTime @default(now()) @map("redemption_date")

  // Pricing Details
  discountAppliedUsd  Decimal @map("discount_applied_usd") @db.Decimal(10, 2)
  originalAmountUsd   Decimal @map("original_amount_usd") @db.Decimal(10, 2)
  finalAmountUsd      Decimal @map("final_amount_usd") @db.Decimal(10, 2)

  // Redemption Status
  redemptionStatus RedemptionStatus @map("redemption_status")
  failureReason    String?          @map("failure_reason") @db.Text

  // Fraud Detection Metadata
  ipAddress String? @map("ip_address") @db.VarChar(45)
  userAgent String? @map("user_agent") @db.Text

  // Timestamps
  createdAt DateTime @default(now()) @map("created_at")

  // Relations
  coupon       Coupon                    @relation(fields: [couponId], references: [id], onDelete: Cascade)
  subscription SubscriptionMonetization? @relation(fields: [subscriptionId], references: [id], onDelete: SetNull)

  @@index([couponId, userId, redemptionDate])
  @@index([userId])
  @@index([subscriptionId])
  @@index([redemptionStatus])
  @@index([redemptionDate])
  @@map("coupon_redemption")
}

// Coupon Usage Limit Table
// Tracks real-time usage counts per coupon for limit enforcement
// Auto-incremented via triggers/transactions on redemption
model CouponUsageLimit {
  id       String @id @default(uuid()) @db.Uuid
  couponId String @unique @map("coupon_id") @db.Uuid

  // Usage Counters
  totalUses              Int @default(0) @map("total_uses")
  uniqueUsers            Int @default(0) @map("unique_users")
  totalDiscountAppliedUsd Decimal @default(0) @map("total_discount_applied_usd") @db.Decimal(12, 2)

  // Last Activity
  lastUsedAt DateTime? @map("last_used_at")

  // Timestamps
  createdAt DateTime @default(now()) @map("created_at")
  updatedAt DateTime @updatedAt @map("updated_at")

  // Relations
  coupon Coupon @relation(fields: [couponId], references: [id], onDelete: Cascade)

  @@index([totalUses])
  @@index([lastUsedAt])
  @@map("coupon_usage_limit")
}

// Coupon Fraud Detection Table
// Logs fraud detection events for security monitoring and pattern analysis
// Integrates with CouponValidationService for real-time blocking
model CouponFraudDetection {
  id       String @id @default(uuid()) @db.Uuid
  couponId String @map("coupon_id") @db.Uuid
  userId   String @map("user_id") @db.Uuid

  // Detection Details
  detectionType FraudDetectionType @map("detection_type")
  severity      FraudSeverity      @map("severity")
  detectedAt    DateTime           @default(now()) @map("detected_at")

  // Event Details (JSONB for flexibility)
  details Json @db.Json
  // Example: {"ip_addresses": ["1.2.3.4", "5.6.7.8"], "velocity": 5, "time_window": "1h"}

  // Flag Status
  isFlagged Boolean @default(false) @map("is_flagged")

  // Review Status
  reviewedBy String?   @map("reviewed_by") @db.Uuid
  reviewedAt DateTime? @map("reviewed_at")
  resolution String?   @db.Text

  // Timestamps
  createdAt DateTime @default(now()) @map("created_at")

  // Relations
  coupon Coupon @relation(fields: [couponId], references: [id], onDelete: Cascade)

  @@index([couponId, severity, isFlagged])
  @@index([userId])
  @@index([detectionType])
  @@index([detectedAt])
  @@map("coupon_fraud_detection")
}

// Coupon Validation Rule Table
// Custom validation rules per coupon for fine-grained eligibility control
// Extensible via JSONB for rule_value configuration
model CouponValidationRule {
  id       String             @id @default(uuid()) @db.Uuid
  couponId String             @map("coupon_id") @db.Uuid
  ruleType ValidationRuleType @map("rule_type")

  // Rule Configuration (JSONB for flexibility)
  ruleValue Json @map("rule_value") @db.Json
  // Examples:
  // first_time_user_only: {}
  // specific_email_domain: {"domains": ["company.com", "example.org"]}
  // minimum_credit_balance: {"min_balance": 1000}
  // exclude_refunded_users: {"days": 90}
  // require_payment_method: {}

  // Status
  isActive Boolean @default(true) @map("is_active")

  // Timestamps
  createdAt DateTime @default(now()) @map("created_at")
  updatedAt DateTime @updatedAt @map("updated_at")

  // Relations
  coupon Coupon @relation(fields: [couponId], references: [id], onDelete: Cascade)

  @@index([couponId, ruleType, isActive])
  @@map("coupon_validation_rule")
}

// Coupon Analytics Snapshot Table
// Daily aggregated metrics for campaign performance tracking
// Generated via cron job for efficient dashboard queries
model CouponAnalyticsSnapshot {
  id           String @id @default(uuid()) @db.Uuid
  snapshotDate DateTime @map("snapshot_date") @db.Date

  // Aggregated Metrics
  totalCouponsActive          Int     @map("total_coupons_active")
  totalRedemptions            Int     @map("total_redemptions")
  totalDiscountValueUsd       Decimal @map("total_discount_value_usd") @db.Decimal(12, 2)
  avgDiscountPerRedemptionUsd Decimal @map("avg_discount_per_redemption_usd") @db.Decimal(10, 2)

  // Top Performing Coupon
  topCouponCode String? @map("top_coupon_code") @db.VarChar(50)

  // Conversion Rate (%)
  conversionRate Decimal @map("conversion_rate") @db.Decimal(5, 2)

  // Timestamps
  createdAt DateTime @default(now()) @map("created_at")

  // Relations
  coupon Coupon? @relation(fields: [topCouponCode], references: [code])

  @@unique([snapshotDate])
  @@index([snapshotDate])
  @@map("coupon_analytics_snapshot")
}
